`include "GLOBAL.sv"

// This module sequentially go through each test state and
// output the testing tetromino, expecting input valid
// which should be generated by a check valid module.
// It is failed when try5 test is reach but the input
// valid is still false. If at any state valid is
// asserted, done will be set to high and the state
// stay the same.
module rotate_counter_clockwise (
    input   logic           clk, enable, valid,
    input   tetromino_ctrl  t,
    output  tetromino_ctrl  t_out,
    output  logic           isFailed, done
  );

  enum {try1 = 0, try2 = 1, try3 = 2, try4 = 3, try5 = 4} ps = try1;

  logic signed [2:0] add_x, add_y;

  // output tetromino has the same tetrmoino type as input
  assign t_out.tetromino = t.tetromino;
  assign t_out.idx = t.idx;

  // output has rotation minu 1 (counter clockwise) and coordinate
  // being added based on the output from clockwise_wallkick_data
  assign t_out.rotation = t.rotation - 1;
  assign t_out.coordinate.x = t.coordinate.x + add_x;
  assign t_out.coordinate.y = t.coordinate.y + add_y;

  counter_clockwise_wallkick_data data (
                            .rotation(t.rotation),
                            .step(ps[2:0]),
                            .idx(t.idx),
                            .add_x, .add_y
                          );

  // failed and done signal
  assign isFailed = (ps == try5) & ~valid;
  assign done = isFailed | valid;

  always_ff @(posedge clk)
    begin
      if (~enable)
        ps <= try1;
      else
        case (ps)
          try1:
            if (~valid)
              ps <= try2;
          try2:
            if (~valid)
              ps <= try3;
          try3:
            if (~valid)
              ps <= try4;
          try4:
            if (~valid)
              ps <= try5;
          try5:
            ;
        endcase
    end

endmodule


// testbench for rotate_counter_clockwise
module rotate_counter_clockwise_testbench();
  logic           clk, enable, valid;
  tetromino_ctrl  t;
  tetromino_ctrl  t_out;
  logic           isFailed, done;

  rotate_counter_clockwise dut (.*);

  // Set up the clock.
  parameter CLOCK_PERIOD=100;
  initial
    clk=1;
  always
    begin
      #(CLOCK_PERIOD/2);
      clk = ~clk;
    end

  initial
    begin
      t.tetromino.data =
        { 4'b0000,
          4'b0100,
          4'b1110,
          4'b0000,

          4'b0000,
          4'b0100,
          4'b0110,
          4'b0100,

          4'b0000,
          4'b0000,
          4'b1110,
          4'b0100,

          4'b0000,
          4'b0100,
          4'b1100,
          4'b0100 }; // test with t block

      t.idx.data <= `TETROMINO_T_IDX;
      t.rotation <= 0;
      t.coordinate.x <= 2;
      t.coordinate.y <= 2;
      valid <= 1;
      enable <= 0;
      @(posedge clk);
      @(posedge clk);
      enable <= 1;
      @(posedge clk);
      enable <= 0;
      valid <= 0;
      @(posedge clk);
      enable <= 1;
      @(posedge done);
      @(posedge clk);
      @(posedge clk);
      @(posedge clk);
      enable <= 0;
      @(posedge clk);
      enable <= 1;
      @(posedge clk);
      valid <= 1;
      @(posedge clk);
      @(posedge clk);
      valid <= 0;
      @(posedge clk);
      valid <= 1;
      @(posedge clk);
      @(posedge clk);
      valid <= 0;
      @(posedge clk);
      valid <= 1;
      @(posedge clk);
      @(posedge clk);
      valid <= 0;
      @(posedge clk);
      @(posedge clk);
      valid <= 1;
      @(posedge clk);
      @(posedge clk);
      valid <= 0;
      $stop;
    end
endmodule
